<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>メダロット風 バトルシミュレーター</title>
    <script src="https://cdn.tailwindcss.com"></script> 
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #1a202c;
            color: #e2e8f0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            overflow: hidden;
        }
        .main-container {
            background-color: #2d3748;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1000px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* バトルフィールド */
        .battlefield {
            width: 100%;
            height: 250px;
            background-color: #4a5568;
            border: 2px solid #718096;
            border-radius: 8px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }
        /* 中央線 */
        .center-line {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: rgba(255, 255, 255, 0.2);
            transform: translateX(-50%);
        }
        /* プレイヤーアイコン */
        .player-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #1a202c;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            transition: left 0.1s linear, transform 0.3s ease, background-color 0.3s ease;
            cursor: pointer;
        }
        /* プレイヤーアイコンの状態 */
        .player-icon.ready-select,
        .player-icon.ready-execute {
            transform: translate(-50%, -50%) scale(1.2); /* 行動可能な時に少し大きく */
            animation: pulse 1.5s infinite;
        }
        .player-icon.broken {
            background-color: #718096 !important;
            color: #a0aec0;
            box-shadow: none;
            filter: grayscale(1);
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
        }
        /* 情報表示エリア */
        .info-panels {
            display: flex;
            justify-content: space-between;
            width: 100%;
            gap: 20px;
        }
        .team-info-panel {
            width: 48%;
            background-color: #4a5568;
            padding: 15px;
            border-radius: 8px;
        }
        .player-info {
            margin-bottom: 10px;
        }
        .player-name {
            font-weight: bold;
        }
        .parts-container {
            display: flex;
            gap: 10px;
            margin-top: 5px;
            font-size: 0.8em;
        }
        .part-hp { display: flex; align-items: center; gap: 4px; }
        .part-hp-bar-container { width: 30px; height: 6px; background-color: #718096; border-radius: 3px; overflow: hidden; }
        .part-hp-bar { height: 100%; transition: width 0.3s ease; }
        .part-hp.broken .part-name { text-decoration: line-through; color: #a0aec0; }
        /* モーダル */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal-content { background: #2d3748; padding: 30px; border-radius: 12px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.5); min-width: 300px; }
        .modal-title { font-size: 1.8em; font-weight: bold; margin-bottom: 15px; }
        .modal-actor { font-size: 1.2em; margin-bottom: 25px; }
        .modal-button { background: #68d391; color: #1a202c; padding: 12px 25px; border-radius: 8px; font-size: 1.1em; cursor: pointer; transition: background-color 0.2s; border:none; }
        .modal-button:hover { background: #48bb78; }
        .part-action-button { background: #4299e1; color: white; padding: 8px 15px; border-radius: 6px; font-size: 0.95em; cursor: pointer; transition: background-color 0.2s ease; border:none; }
        .part-action-button:hover:not(:disabled) { background: #3182ce; }
        .part-action-button:disabled { background: #718096; cursor: not-allowed; opacity: 0.6; }
        .hidden { display: none !important; }
        /* ボタン */
        .buttons-center { display: flex; justify-content: center; gap: 10px; margin-top: 20px; }
        button { background-color: #4299e1; color: white; padding: 10px 20px; border: none; border-radius: 8px; font-size: 1em; cursor: pointer; transition: background-color 0.3s; }
        button:hover { background-color: #3182ce; }
        button:disabled { background-color: #a0aec0; cursor: not-allowed; }
    </style>
</head>
<body>
    <div class="main-container">
        <h1 class="text-3xl font-bold text-center mb-4 text-white">メダロット風 バトルシミュレーター</h1>
        <div id="battlefield" class="battlefield">
            <div class="center-line"></div>
        </div>
        <div class="info-panels">
            <div id="team1InfoPanel" class="team-info-panel">
                <h2 class="text-xl font-bold mb-3 text-blue-300">チーム 1</h2>
            </div>
            <div id="team2InfoPanel" class="team-info-panel">
                <h2 class="text-xl font-bold mb-3 text-red-300">チーム 2</h2>
            </div>
        </div>
        <div class="buttons-center">
            <button id="startButton">シミュレーション開始</button>
            <button id="resetButton" class="bg-red-500 hover:bg-red-600" style="display: none;">リセット</button>
        </div>
    </div>
    <div id="actionModal" class="modal hidden">
        <div class="modal-content">
            <h3 id="modalTitle" class="modal-title"></h3>
            <p id="modalActorName" class="modal-actor"></p>
            <div id="partSelectionContainer" class="buttons-center gap-4 flex-col"></div>
            <button id="modalConfirmButton" class="modal-button" style="display: none;"></button>
            <button id="battleStartConfirmButton" class="modal-button" style="display: none;">戦闘開始！</button>
        </div>
    </div>
    <script>
// <script> タグ内をすべてこちらに置き換えてください
// 1. 設定の一元管理
const CONFIG = {
    MAX_GAUGE: 100,
    UPDATE_INTERVAL: 50,
    PLAYERS_PER_TEAM: 3,
    PART_HP_BASE: 50,
    LEGS_HP_BONUS: 10,
    BASE_DAMAGE: 20,
    TEAMS: {
        team1: { name: 'チーム 1', color: '#63b3ed', baseSpeed: 1.0, textColor: 'text-blue-300' },
        team2: { name: 'チーム 2', color: '#f56565', baseSpeed: 0.9, textColor: 'text-red-300' }
    }
};
class Player {
    constructor(id, name, team, speed, options) {
        this.id = id;
        this.name = name;
        this.team = team;
        this.speed = speed;
        this.isLeader = options.isLeader;
        this.color = options.color;
        this.iconElement = null;
        this.partDOMElements = {}; // 3. DOM参照をキャッシュ
        this.fullReset();
    }
    // --- 状態管理 ---
    fullReset() {
        this.gauge = 0;
        this.state = 'charging';
        this.selectedActionType = null;
        this.selectedPartKey = null;
        this.preparedAttack = null;
        const hp = CONFIG.PART_HP_BASE;
        const legsHp = hp + CONFIG.LEGS_HP_BONUS;
        this.parts = {
            head: { name: '頭部', hp, maxHp: hp, action: 'スキャン', isBroken: false },
            rightArm: { name: '右腕', hp, maxHp: hp, action: '射撃', isBroken: false },
            leftArm: { name: '左腕', hp, maxHp: hp, action: '格闘', isBroken: false },
            legs: { name: '脚部', hp: legsHp, maxHp: legsHp, action: '移動', isBroken: false }
        };
    }
    startCooldown() {
        this.gauge = 0;
        this.state = 'charging';
        this.selectedActionType = null;
        this.selectedPartKey = null;
        this.preparedAttack = null;
    }
    selectAction(partKey) {
        this.selectedPartKey = partKey;
        this.selectedActionType = this.parts[partKey].action;
        this.gauge = 0;
        this.state = 'selected_charging';
    }
    // 2. 責務の分離 (Playerクラスの役割強化)
    getAvailableAttackParts() {
        return Object.entries(this.parts)
            .filter(([key, part]) => !part.isBroken && ['head', 'rightArm', 'leftArm'].includes(key))
            .map(([key, _]) => key);
    }
    isReadyForSelection() {
        return this.state === 'ready_select' || this.state === 'cooldown_complete';
    }
    applyDamage(damage, partKey) {
        const part = this.parts[partKey];
        if (!part) return false;
        part.hp = Math.max(0, part.hp - damage);
        if (part.hp === 0) {
            part.isBroken = true;
            if (partKey === 'head') {
                this.state = 'broken';
                return true; // 頭部破壊
            }
        }
        return false;
    }
    processTurn() {
        if (this.parts.head.isBroken && this.state !== 'broken') this.state = 'broken';
        const statesToPause = ['ready_select', 'ready_execute', 'cooldown_complete', 'broken'];
        if (statesToPause.includes(this.state)) return;
        this.gauge += this.speed;
        if (this.gauge >= CONFIG.MAX_GAUGE) {
            this.gauge = CONFIG.MAX_GAUGE;
            if (this.state === 'charging') this.state = 'cooldown_complete';
            else if (this.state === 'selected_charging') this.state = 'ready_execute';
        }
    }
    // --- UI関連 ---
    createIconDOM(verticalPosition) {
        const icon = document.createElement('div');
        icon.id = `${this.id}-icon`;
        icon.className = 'player-icon';
        icon.style.backgroundColor = this.color;
        icon.style.top = `${verticalPosition}%`;
        icon.style.transform = 'translate(-50%, -50%)';
        icon.textContent = this.name.substring(this.name.length - 1);
        this.iconElement = icon;
        return icon;
    }
    createInfoPanelDOM() {
        const info = document.createElement('div');
        info.className = 'player-info';
        const teamConfig = CONFIG.TEAMS[this.team];
        let partsHTML = '';
        Object.keys(this.parts).forEach(key => {
            partsHTML += `<div id="${this.id}-${key}-part" class="part-hp"></div>`;
        });
        info.innerHTML = `
            <div class="player-name ${teamConfig.textColor}">${this.name} ${this.isLeader ? '(L)' : ''}</div>
            <div class="parts-container">${partsHTML}</div>
        `;
        // 3. DOM参照をキャッシュ
        Object.entries(this.parts).forEach(([key, part]) => {
            const partEl = info.querySelector(`#${this.id}-${key}-part`);
            partEl.innerHTML = `
                <span class="part-name">${part.name.substring(0,1)}</span>
                <div class="part-hp-bar-container"><div class="part-hp-bar"></div></div>
            `;
            this.partDOMElements[key] = {
                container: partEl,
                name: partEl.querySelector('.part-name'),
                bar: partEl.querySelector('.part-hp-bar')
            };
        });
        return info;
    }
    updateDisplay() {
        this.updatePosition();
        this.updateInfoPanel();
    }
    updatePosition() {
        if (!this.iconElement) return;
        const progress = this.gauge / CONFIG.MAX_GAUGE;
        let positionXRatio = (this.team === 'team1') ? 0 : 1;
        if (this.state === 'selected_charging') {
            positionXRatio = (this.team === 'team1') ? (progress * 0.5) : (1 - (progress * 0.5));
        } else if (this.state === 'charging') {
            positionXRatio = (this.team === 'team1') ? (0.5 - (progress * 0.5)) : (0.5 + (progress * 0.5));
        } else if (this.state === 'ready_execute') {
            positionXRatio = 0.5;
        }
        this.iconElement.style.left = `${positionXRatio * 100}%`;
        this.iconElement.classList.toggle('ready-select', this.isReadyForSelection());
        this.iconElement.classList.toggle('ready-execute', this.state === 'ready_execute');
        this.iconElement.classList.toggle('broken', this.state === 'broken');
    }
    updateInfoPanel() {
        Object.entries(this.parts).forEach(([key, part]) => {
            const elements = this.partDOMElements[key];
            if (!elements) return;
            const hpPercentage = (part.hp / part.maxHp) * 100;
            elements.bar.style.width = `${hpPercentage}%`;
            elements.container.classList.toggle('broken', part.isBroken);
            if (part.isBroken) {
                elements.bar.style.backgroundColor = '#4a5568';
            } else {
                if (hpPercentage > 50) elements.bar.style.backgroundColor = '#68d391';
                else if (hpPercentage > 20) elements.bar.style.backgroundColor = '#f6e05e';
                else elements.bar.style.backgroundColor = '#f56565';
            }
        });
    }
}
class GameManager {
    constructor() {
        this.players = [];
        this.simulationInterval = null;
        this.activePlayer = null;
        this.phase = 'IDLE'; // IDLE, INITIAL_SELECTION, BATTLE_START_CONFIRM, BATTLE, GAME_OVER
        this.dom = {
            startButton: document.getElementById('startButton'),
            resetButton: document.getElementById('resetButton'),
            battlefield: document.getElementById('battlefield'),
            modal: document.getElementById('actionModal'),
            modalTitle: document.getElementById('modalTitle'),
            modalActorName: document.getElementById('modalActorName'),
            partSelectionContainer: document.getElementById('partSelectionContainer'),
            modalConfirmButton: document.getElementById('modalConfirmButton'),
            battleStartConfirmButton: document.getElementById('battleStartConfirmButton')
        };
        Object.values(CONFIG.TEAMS).forEach(team => {
            this.dom[team.name.replace(/\s/g, '')] = document.getElementById(`${team.name.replace(/\s/g, '')}InfoPanel`);
        });
    }
    init() { this.createPlayers(); this.setupUI(); this.bindEvents(); }
    createPlayers() {
        this.players = [];
        Object.entries(CONFIG.TEAMS).forEach(([teamId, teamConfig], teamIndex) => {
            for (let i = 0; i < CONFIG.PLAYERS_PER_TEAM; i++) {
                const id = teamIndex * CONFIG.PLAYERS_PER_TEAM + i + 1;
                this.players.push(new Player(
                    `p${id}`, `メダロット ${id}`, teamId,
                    teamConfig.baseSpeed + (Math.random() * 0.2),
                    { isLeader: i === 0, color: teamConfig.color }
                ));
            }
        });
    }
    setupUI() {
        this.dom.battlefield.innerHTML = '<div class="center-line"></div>';
        Object.entries(CONFIG.TEAMS).forEach(([teamId, teamConfig]) => {
            const panel = document.getElementById(`${teamId}InfoPanel`);
            panel.innerHTML = `<h2 class="text-xl font-bold mb-3 ${teamConfig.textColor}">${teamConfig.name}</h2>`;
        });
        this.players.forEach(player => {
            const idNum = parseInt(player.id.substring(1));
            const indexInTeam = (idNum - 1) % CONFIG.PLAYERS_PER_TEAM;
            const vPos = 25 + indexInTeam * 25;
            this.dom.battlefield.appendChild(player.createIconDOM(vPos));
            const panel = document.getElementById(`${player.team}InfoPanel`);
            panel.appendChild(player.createInfoPanelDOM());
            player.updateDisplay();
        });
    }
    bindEvents() {
        this.dom.startButton.addEventListener('click', () => this.start());
        this.dom.resetButton.addEventListener('click', () => this.reset());
        this.dom.modalConfirmButton.addEventListener('click', () => this.handleModalConfirm());
        this.dom.battleStartConfirmButton.addEventListener('click', () => this.handleBattleStartConfirm());
    }
    start() {
        if (this.phase !== 'IDLE') return;
        this.phase = 'INITIAL_SELECTION';
        this.players.forEach(p => { p.gauge = CONFIG.MAX_GAUGE; p.state = 'ready_select'; p.updateDisplay(); });
        this.dom.startButton.disabled = true; this.dom.startButton.textContent = "シミュレーション中...";
        this.dom.resetButton.style.display = "inline-block";
        this.resumeSimulation();
    }
    pauseSimulation() { clearInterval(this.simulationInterval); this.simulationInterval = null; }
    resumeSimulation() { if (this.simulationInterval) return; this.simulationInterval = setInterval(() => this.gameLoop(), CONFIG.UPDATE_INTERVAL); }
    reset() {
        this.pauseSimulation();
        this.phase = 'IDLE'; this.activePlayer = null;
        this.hideModal();
        this.players.forEach(p => p.fullReset());
        this.setupUI();
        this.dom.startButton.disabled = false; this.dom.startButton.textContent = "シミュレーション開始";
        this.dom.resetButton.style.display = "none";
    }
    // 4. メインループの単純化
    gameLoop() {
        if (this.activePlayer || !['INITIAL_SELECTION', 'BATTLE'].includes(this.phase)) return;
        // 優先順位1: 行動実行
        const playerToExecute = this.players.find(p => p.state === 'ready_execute');
        if (playerToExecute) {
            return this.handleActionExecution(playerToExecute);
        }
        // 優先順位2: 行動選択
        const playerToSelect = this.players.find(p => p.isReadyForSelection());
        if (playerToSelect) {
            return this.handleActionSelection(playerToSelect);
        }
        // 誰も行動しない場合
        if (this.phase === 'INITIAL_SELECTION') {
            // 全員が選択を終えたら戦闘開始確認へ
            if (this.players.every(p => p.state !== 'ready_select')) {
                this.phase = 'BATTLE_START_CONFIRM';
                this.pauseSimulation();
                this.showModal('battle_start_confirm');
            }
        } else if (this.phase === 'BATTLE') {
            this.players.forEach(p => { p.processTurn(); p.updateDisplay(); });
        }
    }
    handleActionExecution(player) {
        this.activePlayer = player;
        this.pauseSimulation();
        this.prepareAndShowExecutionModal(player);
    }
    handleActionSelection(player) {
        player.state = 'ready_select'; // cooldown_complete を正規化
        if (player.team === 'team2') { // CPU
            const target = this.findEnemyTarget(player);
            const partKey = player.getAvailableAttackParts()[0]; // とりあえず最初のパーツ
            if (target && partKey) player.selectAction(partKey); else player.state = 'broken';
        } else { // Human
            this.activePlayer = player;
            this.pauseSimulation();
            this.showModal('selection', player);
        }
    }
    findEnemyTarget(attacker) {
        const enemies = this.players.filter(p => p.team !== attacker.team && p.state !== 'broken');
        if (enemies.length === 0) return null;
        return enemies.find(e => e.isLeader) || enemies[0];
    }
    handlePartSelection(partKey) {
        if (!this.activePlayer) return;
        this.activePlayer.selectAction(partKey);
        this.activePlayer = null;
        this.hideModal();
        this.resumeSimulation();
    }
    handleBattleStartConfirm() {
        this.phase = 'BATTLE';
        this.players.forEach(p => p.processTurn());
        this.hideModal();
        this.resumeSimulation();
    }
    handleModalConfirm() {
        if (this.phase === 'GAME_OVER') return this.reset();
        if (!this.activePlayer) return;
        const attacker = this.activePlayer;
        if (attacker.preparedAttack) {
            const { target, partKey, damage } = attacker.preparedAttack;
            if (target.applyDamage(damage, partKey) && target.isLeader) {
                this.phase = 'GAME_OVER';
                this.showModal('game_over', null, { winningTeam: attacker.team });
                this.pauseSimulation();
                return;
            }
        }
        attacker.startCooldown();
        this.activePlayer = null;
        this.hideModal();
        this.resumeSimulation();
    }
    prepareAndShowExecutionModal(player) {
        const target = this.findEnemyTarget(player);
        if (!target) { return player.startCooldown(); }
        const availableTargetParts = Object.keys(target.parts).filter(key => !target.parts[key].isBroken);
        if (availableTargetParts.length === 0) { return player.startCooldown(); }
        const targetPartKey = availableTargetParts[Math.floor(Math.random() * availableTargetParts.length)];
        player.preparedAttack = {
            target: target,
            partKey: targetPartKey,
            damage: CONFIG.BASE_DAMAGE
        };
        this.showModal('execution', player);
    }
    showModal(type, player = null, data = {}) {
        const modal = this.dom.modal;
        const title = this.dom.modalTitle;
        const actorName = this.dom.modalActorName;
        const partContainer = this.dom.partSelectionContainer;
        const confirmBtn = this.dom.modalConfirmButton;
        const startBtn = this.dom.battleStartConfirmButton;
        // Reset all
        [partContainer, confirmBtn, startBtn].forEach(el => el.style.display = 'none');
        modal.className = 'modal';
        switch (type) {
            case 'selection':
                title.textContent = '行動選択';
                actorName.textContent = `${player.name} の番です。`;
                partContainer.innerHTML = '';
                player.getAvailableAttackParts().forEach(partKey => {
                    const part = player.parts[partKey];
                    const button = document.createElement('button');
                    button.className = 'part-action-button';
                    button.textContent = `${part.name} (${part.action})`;
                    button.onclick = () => this.handlePartSelection(partKey);
                    partContainer.appendChild(button);
                });
                partContainer.style.display = 'flex';
                break;
            case 'execution':
                const { target, partKey, damage } = player.preparedAttack;
                title.textContent = '攻撃実行！';
                actorName.textContent = `${player.name}の${player.selectedActionType}！ ${target.name}の${target.parts[partKey].name}に${damage}ダメージ！`;
                confirmBtn.style.display = 'inline-block';
                confirmBtn.textContent = 'OK';
                break;
            case 'battle_start_confirm':
                title.textContent = '戦闘開始！';
                actorName.textContent = '';
                startBtn.style.display = 'inline-block';
                break;
            case 'game_over':
                title.textContent = `${CONFIG.TEAMS[data.winningTeam].name} の勝利！`;
                actorName.textContent = 'ロボトル終了！';
                confirmBtn.style.display = 'inline-block';
                confirmBtn.textContent = 'リセット';
                modal.classList.add('game-over-modal'); // You might need specific styles for this
                break;
        }
        modal.classList.remove('hidden');
    }
    hideModal() { this.dom.modal.classList.add('hidden'); }
}
document.addEventListener('DOMContentLoaded', () => {
    const game = new GameManager();
    game.init();
});
    </script>
</body>
</html>
